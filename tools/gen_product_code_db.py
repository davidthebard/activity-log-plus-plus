#!/usr/bin/env python3
"""
Generate source/product_code_db_data.c from one or more 3DS title database JSON files.

Usage:
    python tools/gen_product_code_db.py <input1.json> [input2.json ...] [-o output.c]

    output.c defaults to source/product_code_db_data.c if -o is not specified.
    Files listed first take priority on duplicate title IDs.

Uses the same JSON sources as gen_title_db.py (https://github.com/hax0kartik/3dsdb):
    curl -L -o tools/list_US.json "https://raw.githubusercontent.com/hax0kartik/3dsdb/master/jsons/list_US.json"
    curl -L -o tools/list_GB.json "https://raw.githubusercontent.com/hax0kartik/3dsdb/master/jsons/list_GB.json"
    curl -L -o tools/list_JP.json "https://raw.githubusercontent.com/hax0kartik/3dsdb/master/jsons/list_JP.json"
    curl -L -o tools/list_KR.json "https://raw.githubusercontent.com/hax0kartik/3dsdb/master/jsons/list_KR.json"

Only game titles are indexed (high 32 bits == 0x00040000 for retail 3DS, or
0x00048004 for DSiWare). Updates (0x0004000E) and system titles are skipped.

Product codes must be in the form XXX-Y-ZZZZ (e.g. "CTR-P-AMKE", "TWL-P-HNHA").
Only the 4-letter suffix ZZZZ is stored; it is used as the GameTDB icon URL key.
"""

import argparse
import json
import os
import sys

# Title ID high words that correspond to playable game titles
GAME_HIGH_WORDS = {0x00040000, 0x00048004}


def extract_game_code(product_code_str):
    """
    Extract the 4-letter game code from a product code string.
    e.g. "CTR-P-AMKE" -> "AMKE", "TWL-P-HNHA" -> "HNHA"
    Returns None if the string doesn't match the expected format.
    """
    parts = product_code_str.strip().split('-')
    if len(parts) < 2:
        return None
    code = parts[-1]
    if len(code) != 4:
        return None
    # All four chars must be printable ASCII (typically uppercase alphanumeric)
    if not all(0x20 <= ord(c) <= 0x7E for c in code):
        return None
    return code


def parse_file(path):
    """
    Parse a 3dsdb JSON file and return a dict of {title_id (int): game_code (str)}.
    Only game title IDs (high word in GAME_HIGH_WORDS) with valid product codes
    are included.
    """
    with open(path, 'r', encoding='utf-8') as f:
        raw = f.read()

    try:
        data = json.loads(raw)
    except json.JSONDecodeError as e:
        print(f'  JSON parse error in {path}: {e}', file=sys.stderr)
        return {}

    if not isinstance(data, list):
        print(f'  Skipping {path}: expected a JSON array', file=sys.stderr)
        return {}

    entries = {}
    skipped_type = 0
    skipped_code = 0

    for item in data:
        if not isinstance(item, dict):
            continue

        tid_str = (item.get('TitleID') or item.get('titleID') or
                   item.get('title_id') or '').strip()
        pc_str  = (item.get('Product Code') or item.get('ProductCode') or
                   item.get('product_code') or '').strip()

        if not tid_str or not pc_str:
            continue

        try:
            tid = int(tid_str, 16)
        except ValueError:
            continue

        # Filter to game title IDs only
        hi = (tid >> 32) & 0xFFFFFFFF
        if hi not in GAME_HIGH_WORDS:
            skipped_type += 1
            continue

        code = extract_game_code(pc_str)
        if not code:
            skipped_code += 1
            continue

        if tid not in entries:
            entries[tid] = code

    print(f'  {len(entries)} game entries, '
          f'{skipped_type} non-game titles skipped, '
          f'{skipped_code} bad product codes skipped')
    return entries


def escape_c(s):
    return s.replace('\\', '\\\\').replace('"', '\\"')


def main():
    parser = argparse.ArgumentParser(
        description='Generate product_code_db_data.c from 3DS title database JSON files.')
    parser.add_argument('inputs', nargs='+', metavar='input.json',
                        help='One or more JSON database files (first file wins on duplicates)')
    parser.add_argument('-o', '--output', default='source/product_code_db_data.c',
                        metavar='output.c',
                        help='Output C source file (default: source/product_code_db_data.c)')
    args = parser.parse_args()

    merged = {}
    for path in args.inputs:
        print(f'Reading {path}...')
        file_entries = parse_file(path)
        added = 0
        for tid, code in file_entries.items():
            if tid not in merged:
                merged[tid] = code
                added += 1
        print(f'  {added} new entries added')

    sorted_entries = sorted(merged.items())
    source_names = ', '.join(os.path.basename(p) for p in args.inputs)

    with open(args.output, 'w', encoding='utf-8') as f:
        f.write('/* Auto-generated by tools/gen_product_code_db.py â€” do not edit manually.\n')
        f.write(f' * Sources: {source_names}\n')
        f.write(' * Re-run the script to update.\n')
        f.write(' */\n')
        f.write('#include "product_code_db.h"\n\n')
        f.write('const ProductCodeEntry product_code_db[] = {\n')
        if sorted_entries:
            for tid, code in sorted_entries:
                f.write(f'    {{ 0x{tid:016X}ULL, "{escape_c(code)}" }},\n')
        else:
            f.write('    { 0x0000000000000000ULL, "" }, /* stub */\n')
        f.write('};\n\n')
        f.write('const int product_code_db_count =\n')
        f.write('    (int)(sizeof(product_code_db) / sizeof(product_code_db[0]));\n')

    print(f'Wrote {len(sorted_entries)} total entries to {args.output}')


if __name__ == '__main__':
    main()
